<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    

    <script>
        // 반복적인 사고를 통한 방법 for 문 이용
        function pow(x, n){
            let result = 1;

            for(let i = 0; i < n; i++){
                result *= x;
            }

            return result;
        }

        console.log(pow(2, 3));


        // 재귀적인 사고를 이용한 방법
        // 작업을 단순화, 자기자신을 호출
        function pow(x, n){
            if (n === 1){ // 재귀의 베이스, pow(x, 1) === x
                return x;
            } else {        // pow(x, n) === x * pow(x, n-1), 재귀 단계, pow는 n === 1이 될때까지 재귀적으로 자신을 호출
                return x * pow(x, n -1);
            }
        }

        console.log(pow(2, 2));

        // 조건부 연산자 사용

        function pow(x, n){
            return (n === 1) ? x : (x * pow(x, n-1));
        }

        console.log(pow(2, 2));

        // 재귀적 순회

        let company = {
            sales : [{name: 'John', salary: 1000}, {name: 'Alice', salary: 1600}],

            development: {
                sites:[{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800}],
                internals: [{name: 'Jack', salary: 1300}]
            }
        };

        // 급여 합계를 구해주는 함수
        function sumSalaries(department){
            if(Array.isArray(department)){ // 첫 번째 경우
                // reduce 메서드 : 배열의 요소들을 순회하면서 반복적인 연산을 하는 메서드
                // 사용법 : 배열명.reduce((콜백함수, 초기값))
                return department.reduce((prev, current) => prev + current.salary, 0); // 배열의 요소를 합함
            } else { // 두 번째 경우
                let sum = 0;
                for(let subdep of Object.values(department)){
                    sum += sumSalaries(subdep); // 재귀 호출로 각 하위 부서 임직원의 급여 총합 구함
                }
                return sum;
            }
        }

        alert(sumSalaries(company));

        // 연결리스트
        // 빠르게 삽입 혹은 삭제를 해야할 때는 배열 대신 연결 리스트라 불리는 자료구조 이용
        // 연결리스트의 요소 : 객체와 프로퍼티들을 조합해 정의할 수 있음
        // value
        // next : 다음 연결 리스트 요소를 참조하는 프로퍼티. 다음 요소가 없을 땐 null

        // let list = {
        //     value: 1,
        //     next:{
        //         value: 2,
        //         next:{
        //             value:3,
        //             next:{
        //                 value:4,
        //                 next: null
        //             }
        //         }
        //     }
        // };

        // 위 코드와 동일한 연결리스트
        // let list = { value: 1 };
        // list.next = { value: 2 };
        // list.next.next = { value: 3 };
        // list.next.next.next = { value: 4 };
        // list.next.next.next.next = null;

        // 연결리스트 : 전체 리스트를 여러 부분으로 쉽게 나눌 수 있고, 다시 합치는 것도 가능
        // let secondList = list.next.next;
        // list.next.next = null;
        // // 합치기
        // list.next.next = secondList;
        // console.log(list.next.next);

        // 요소를 추가하거나 삭제
        let list = { value: 1 };
        list.next = { value: 2 };
        list.next.next = { value: 3 };
        list.next.next.next = { value: 4 };
        // list에 새로운 value를 추가
        list = { value: "new itme", next: list};
        // 중간 요소를 제거 : 이전 요소의 next를 변경
        list.next = list.next.next;

        // 요약
        // 재귀 : 함수 내부에서 자기 자신을 호출하는 것을 나타내는 프로그래밍 언어
        //        함수가 자신을 호출하는 단계 = 재귀단계

        // 반복문 사용
        function sumTo(n){
            let sum = 0;
            for(let i = 1; i <= n; i++){
                sum += i;
            }
            return sum;
        }
        console.log(sumTo(100));


        // 재귀함수 사용
        function sumTo(n){
            if(n === 1) return 1;
            return n + sumTo(n-1);
        }
        console.log(sumTo(100));

        // 등차수열의 합 공식 이용
        function sumTo(n){
            return n * (n + 1) / 2;
        }
        console.log(sumTo(100));
    </script>
</body>
</html>